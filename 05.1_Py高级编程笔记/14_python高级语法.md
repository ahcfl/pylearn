### 14.1. 今日目标
### 14.2.【理解】在原装饰器上设置外部变量

* 作用：向装饰器内部传递参数

* 格式：

  ```
  def test(path):
     def function_out(func):
     	  def function_in():
     	     ....
     	  return function_in
     return function_out
  ```

* 使用：

  @test("login.py")

  > 1) test(login.py)  --->   function_out
  >
  > 2) @  第一步的结果      ——> @ founction_out

### 14.3.【理解】多重装饰器

* 多重装饰器：给一个函数进行多次装饰
* 装饰原则：就近原则（靠近待装饰函数的先装饰，随后一层一层装饰）

### 14.4.【了解】类装饰器

* 作用：使用一个类为一个函数装饰

* 类的书写：

  > 必须有两个方法
  >
  > 1) init 方法，必须接收 装饰器传递的参数 func
  >
  > 2）call方法,  self.func()

  ```
  # 装饰器类
  class Test(object):
  
      def __init__(self,func):
          print("----init----方法")
          print("---func--", func)
          # func 是login函数的引用
          self.func = func
  
      def run(self):
          print("---正在疯跑---")
  
      def __call__(self, *args, **kwargs):
          print("----开始验证----")
          # 调用原来login的内容
          self.func()
  ```

* 格式：@类名

  ​           待装饰的函数

  >
  >
  > @Test
  >
  > def login():
  >
  > login = Test(login)
  >
  > login()    ---> 调用类的 `__call__`方法

* 对象名()    调用对象的 `__call__()`


### 14.5.【了解】GIL锁引入

* 监控资源的竞争情况 htop
* 资源的消耗的情况
  * 单进程    1核
  * 多进程    多核
  * 多线程    多核但是很低   gil锁的问题

### 14.6.【了解】GIL概念及影响

* Gil 全局解释器锁
* GIL跟python语言没有关系，Python底层解释器Cpython的问题
* GIL释放的情况
  * 线程执行完毕释放
  * I/O 阻塞的时候释放
  * Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL)

### 14.7.【理解】GIL解决方案

* 解决方案：
  * 更换解释器 Jpython  pypy
  * 用进程替换线程（进程会占用更多的系统资源）
  * 子线程用C语言实现（test.c-->libtest.so-->python加载）

### 14.8.【理解】python中可变和不可变

* 可变类型（**mutable**），创建后可以继续修改对象的内容（值）

  > 字典、列表

* 不可变类型（**unmutable**） ，一旦创建就不可修改的对象（值）

  > 数字， 字符串，元组
  >
  > 当内容发生修改，计算机重新分配一块内存空间

### 14.9.【理解】简单可变类型拷贝

* 深拷贝：

  * 会产生新的空间
  * 能够保持各自的独立性
  * 如果拷贝的对象，子对象也会拷贝（产生新的空间）

* 浅拷贝

  * 不会产生新的空间
  * 源对象和副本对象指向同一个空间
  * 如果拷贝的对象，子对象不会拷贝（不会产生新的空间）

* 简单可变类型的拷贝总结：

  > 简单可变类型的数据不管深拷贝还是浅拷贝，都会产生新的空间，而且保持各自的独立性

### 14.10.【理解】复杂可变类型拷贝

* 复杂可变类型的深浅拷贝问题
  * 浅拷贝，拷贝的是顶层对象的值，子对象不会拷贝（只是引用子对象）
  * 深拷贝，拷贝的顶层对象和对象的子对象，子对象会产生新的内存空间

### 14.11.【理解】简单不可变类型拷贝
* 简单不可变类型
  * copy()      浅拷贝，副本和源指向同一个空间
  * deepcopy()   浅拷贝，副本和源指向同一个空间

### 14.12.【理解】复杂不可变类型拷贝

* 复杂不可变类型的拷贝问题
  * 浅拷贝， 直接引用
  * 深拷贝，看数据具体是可变还是不可变的，如果数据是可变的，会产生新的空间，保持数据的独立性

### 14.13.【理解】切片拷贝、字典拷贝

* 切片拷贝：  浅拷贝(如果是简单可变类型，底层会产生新的空间)
* 字典拷贝： 浅拷贝

### 14.14. 总结