### 1.TCP 的 3 次握⼿是⽤于建⽴连接

》tcp建立连接的时候发送的三次数据包
》第一Client发送一个连接请求（SYN）
》第二Server给Client一个确认响应（ACK）
》第三Client给Server一个ACK
》一次不能多一次不能少 ，多了浪费系统资源，少了服务器不断重复的发ACK/客户端可能产生新的连接SYN（请求）

### 2.TCP 的 4 次挥⼿是⽤于断开连接》》

》在tcp断开连接的时候 发送四个数据包，确认正常的断开
》1、主动发起的一方发送断开连接的请求（SYN）->server
》2、服务器会回复ACK（确认收到断开），并不会立刻断开
》3、服务器程序跑完（事情处理完），重新向主动发起断开的一方，发送同意断开
》4、主动发起的一方再做个确认
主动发起的一方等待2MSL时间，最后一次server发送的包出问题了，可以再次传送，等待接收。

### 3.为什么TIME_WAIT状态需要经过2MSL(最⼤报⽂段⽣存时间)才能返回到CLOSE状态？

⾸先，MSL即Maximum Segment Lifetime，就是最⼤报⽂⽣存时间，是任何报⽂在⽹络上 的存在的最⻓时间，
超过这个时间报⽂将被丢弃。
《TCP/IP详解》中是这样描述的：MSL是任何 报⽂段被丢弃前在⽹络内的最⻓时间。
RFC 793中规定MSL为2分钟，实际应⽤中常⽤的是30 秒、1分钟、2分钟等

等待2MSL时间主要⽬的是：防⽌最后⼀个ACK包对⽅没有 收到，
那么对⽅在超时后将重发第三次握⼿的FIN包，
主动关闭端接到重发的FIN包后可以再发⼀ 个ACK应答包。

在TIME_WAIT状态时两端的端⼝不能使⽤，要等到2MSL时间结束才可以继续使⽤。
当连接处于2MSL等待阶段时任何迟到的报⽂段都将被丢弃。

### 4.为什么连接的时候是三次握⼿，关闭的时候却是四次握⼿？ 

因为当Server收到Client的SYN连接请求报⽂后，可以直接发送SYN+ACK报⽂。
其中 ACK报⽂是⽤来应答的，SYN报⽂是⽤来同步的。————> 三次就可以

但是关闭连接时，当Server收到FIN报⽂ 时，很可能并不会⽴即关闭SOCKET，所以只能先回复⼀个ACK报⽂，
告诉Client，"你发的 FIN报⽂我收到了"。
只有等到Server端所有的报⽂都发送完了,发送FIN报⽂，
Client等待2MSL时间，最后一次server发送的包出问题了，可以再次传送。client等待接收，回复确认。
因此不 能⼀起发送。故需要四步握⼿。

### 5.数据库就是以⼀定格式进⾏组织的数据的集合。

通俗来看数据库就是⽤户计算机上 ⼀些具有特殊格式 的数据⽂件的集合。
1）. 关系数据库 关系型数据库管理系统-RDBMS（Relational Database Management System）
 所谓的关系型数据库RDBMS，是建⽴在关系模型基础上的数据库，
借助于集合代数等数学概念和 ⽅法来处理数据库中的数据，
本质上使⽤⼀张⼆维表来表示关系。

2. ⾮关系型数据库 ⾮关系型数据库，⼜被称为NoSQL（Not Only SQL )，
意为不仅仅是SQL，对NoSQL 最普遍的定 义是“⾮关联型的”，强调Key-Value 存储和⽂档数据库的优点

### 6.MySQL中定义数据字段的类型对你数据库的优化是⾮常重要的。

MySQL⽀持多种类型，⼤致可以 分为三类：数值、⽇期/时间和字符串(字符)类型。

### 7.GIL⾯试题 描述Python GIL的概念， 以及它对python多线程的影响？

编写⼀个多线程抓取⽹⻚的程序，并阐 明多线程抓取程序是否可⽐单线程性能有提升，并解释原因。
》Python语⾔和GIL没有半⽑钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除 GIL。 
》GIL：全局解释器锁。每个线程在执⾏的过程都需要先获取GIL，保证同⼀时刻只有⼀个线程可以 执⾏代码。

》线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,
    但在执⾏完毕后,必须重新获 取GIL Python 3.x使⽤计时器（执⾏时间达到阈值后，当前线程释放GIL）
    或Python 2.x，tickets计数 达到100 Python使⽤多进程是可以利⽤多核的CPU资源的。 
     多线程爬取⽐单线程性能有提升，因为遇到IO阻塞会⾃动释放GIL锁

### 8.多继承的问题

如果2个⼦类中都继承了⽗类，当在⼦类中通过⽗类名调⽤时，parent被执⾏了2次 

如果2个⼦类中都继承了⽗类，当在⼦类中通过super调⽤时，parent被执⾏了1次

1、MRO保证了多继承情况 每个类只出现⼀次 

2、super().__init__相对于类名.__init__，在单继承上⽤法基本⽆差 

3、但在多继承上有区别，super⽅法能保证每个⽗类的⽅法只会执⾏⼀次，⽽使⽤类名的⽅法会 

导致⽅法被执⾏多次 

4、多继承时，使⽤super⽅法，对⽗类的传参数，应该是由于python中super的算法导致的原 

因，必须把参数全部传递，否则会报错 

5、多继承时，相对于使⽤类名.__init__⽅法，要把每个⽗类全部写⼀遍, ⽽使⽤super⽅法，只 

需写⼀句话便执⾏了全部⽗类的⽅法，这也是为何多继承需要全部传参的⼀个原因

 ![多继承_super().__inin_()](C:\Users\16096\Desktop\多继承_super().__inin_().png)![多继承_父类名调用1](C:\Users\16096\Desktop\多继承_父类名调用1.png)